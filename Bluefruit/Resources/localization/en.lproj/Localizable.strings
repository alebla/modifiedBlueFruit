// AUTO-GENERATED
// General


// Bluetooth Management

"bluetooth_unsupported" = "This device doesn't support Bluetooth Low Energy";
"bluetooth_notauthorized" = "This app is not authorized to use the Bluetooth Low Energy";
"bluetooth_poweredoff" = "Bluetooth is currently powered off";

"bluetooth_locationpermission_disabled_text" = "Location Services should be enabled to scan bluetooth peripherals.\nPlease, go to settings and enable it to start scanning peripherals";
"bluetooth_locationpermission_title" = "This app needs location access";
"bluetooth_locationpermission_text" = "Please grant location access so this app can scan for Bluetooth peripherals";
"bluetooth_locationpermission_notavailable_title" = "Bluetooth Scanning not available";
"bluetooth_locationpermission_notavailable_text" = "Since location access has not been granted, the app will not be able to scan for Bluetooth peripherals";
"bluetooth_scanner_errorregisteringapp" = "App cannot be registered for bluetooth scanning.
Please reset bluetooth and try again.";
"bluetooth_connecting_error" = "Error connecting to peripheral";
"bluetooth_advertising_start_error" = "Error starting advertising";

// Main Tab-Bar
"main_tabbar_centralmode" = "Central Mode";
"main_tabbar_peripheralmode" = "Peripheral Mode";


// Scanner
"scanner_title" = "Peripherals";
"scanner_backbutton" = "Disconnect";
"scanner_splitmasterbutton" = "Peripheral List";
"scanner_subtitle" = "Peripherals found";
"scanner_uartavailable" = "Uart capable";
"scanner_beacon" = "Beacon";
"scanner_uribeacon" = "Uri-Beacon";
"scanner_notconnectable" = "Not Connectable";
"scanner_peripheraldisconnected" = "Peripheral disconnected";
"scanner_unnamed" = "<Unknown>";
"scanner_connect" = "Connect";
"scanner_disconnect" = "Disconnect";

"scanner_filter_name_title" = "Name:";
"scanner_filter_name_hint" = "Filter by name";
"scanner_filter_rssi_title" = "RSSI >=";
"scanner_filter_rssi_description_format" = "RSSI >= %ld";
"scanner_filter_unnamed_title" = "Show unnamed devices";
"scanner_filter_unnamed_description" = "with name";
"scanner_filter_uart_title" = "Must have UART Service";
"scanner_filter_uart_description" = "with UART";
"scanner_filter_name_matchsection" = "Match";
"scanner_filter_name_casesection" = "Case sensitivity";
"scanner_filter_currentfilter_format" = "Filter: %@";
"scanner_filter_nofilter" = "No filter selected";
"scanner_filter_rssivalue_format" = "%ld dBM";

"scanner_filter_name_settings_contains" = "Name contains";
"scanner_filter_name_settings_exact" = "Name equals";
"scanner_filter_name_settings_sensitive" = "Matching case";
"scanner_filter_name_settings_insensitive" = "Ignoring case";

"scanner_filteredoutinfo_single_format" = "%ld peripheral filtered out";
"scanner_filteredoutinfo_multiple_format" = "%ld peripherals filtered out";


// Scan Result
"scanresult_connect" = "Connect";
"scanresult_disconnect" = "Disconnect";

"scanresult_advertisement_viewrawdata" = "View Raw Data";
"scanresult_advertisement_rawdata_title" = "Advertising Raw Data";

"scanresult_advertisement_localname" = "Local name";
"scanresult_advertisement_address" = "Address";
"scanresult_advertisement_manufacturer" = "Manufacturer";
"scanresult_advertisement_services" = "Services";
"scanresult_advertisement_servicesuuids" = "Services UUIDs";
"scanresult_advertisement_overflowservices" = "Overflow services";
"scanresult_advertisement_servicesdata" = "Services data";
"scanresult_advertisement_servicesdata_uuid" = "UUID";
"scanresult_advertisement_servicesdata_data" = "Data";
"scanresult_advertisement_servicessolicited" = "Services solicited";
"scanresult_advertisement_connectable" = "Connectable";
"scanresult_advertisement_connectable_true" = "true";
"scanresult_advertisement_connectable_false" = "false";
"scanresult_advertisement_connectable_unknown" = "unknown";
"scanresult_advertisement_datapacket" = "Advertising packet data";
"scanresult_advertisement_txpower" = "TX Power Level";

"scanresult_advertisement_uribeacon_uri" = "Uri";
"scanresult_advertisement_beacon_uuid" = "UUID";
"scanresult_advertisement_beacon_major" = "Major";
"scanresult_advertisement_beacon_minor" = "Minor";


// Multiconnect Management
"multiconnect_title" = "Multiple UART mode";
"multiconnect_connecteddevices_single_format" = "Connected to %ld device";
"multiconnect_connecteddevices_multiple_format" = "Connected to %ld devices";
"multiconnect_start_action" = "Start";

// Peripheral Mode
"peripheral_advertisinginfo" = "Advertising Info";
"peripheral_localname" = "Local Name";
"peripheral_services" = "Services";
"peripheral_characteristics" = "Characteristics";

"peripheral_unknown_title" = "Undefined Peripheral";
"peripheral_dis_title" = "Device Information Service";
"peripheral_uart_title" = "UART";

"peripheral_advertising_starterror_undefined" = "Peripheral mode can't not be started";
"peripheral_advertising_starterror_toolarge" = "Peripheral mode can't not be started: Advertising data too large";

// Peripheral Dis
"peripheral_dis_manufacturer" = "Manufacturer";
"peripheral_dis_modelnumber" = "Model Number";
"peripheral_dis_serialnumber" = "Serial Number";
"peripheral_dis_hardwarenumber" = "Hardware Number";
"peripheral_dis_firmwarerevision" = "Firmware Revision";
"peripheral_dis_softwarerevision" = "Software Revision";


// AutoUpdate Firmware
"autoupdate_title" = "Update available";
"autoupdate_description_format" = "Software version %@ is available";
"autoupdate_update" = "Go to updates";
"autoupdate_later" = "Ask later";
"autoupdate_ignore" = "Ignore";


// Peripheral Details
"peripheraldetails_select" = "Connect to a peripheral from the list on the left";
"peripheraldetails_connecting" = "Connecting...";
"peripheraldetails_discoveringservices" = "Discovering services...";
"peripheraldetails_errordiscoveringservices" = "Error discovering peripheral services";
"peripheraldetails_checkingupdates" = "Checking updates...";

// Peripheral Modules
"peripheralmodules_title" = "Modules";
"peripheralmodules_sectiontitle_device_single" = "Device";
"peripheralmodules_sectiontitle_device_multiconnect" = "Multiple Devices";
"peripheralmodules_sectiontitle_modules" = "Modules";
"peripheralmodules_rssi_format" = "%ld dBm";
"peripheralmodules_rssi_unavailable" = "not available";
"peripheralmodules_battery_format" = "%ld%%";

// Info
"info_tab_title" = "Info";
"info_navigation_title_format" = "Info - %@";

"info_type_service" = "Service";
"info_type_characteristic" = "Characteristic";
"info_type_descriptor" = "Descriptor";
"info_data_hex" = "Data (Hex):";
"info_data_dec" = "Data (Dec):";

"info_uuid" = "UUID:";


"info_help_title" = "Info";
"info_help_text" = "• Each section of the table represents one of the peripheral's services followed by its relevant characteristics.

• If a service or characteristic uses a predefined UUID, a standardized name is displayed.  Otherwise the UUID value is shown.

• If a characteristic contains a readable value, that value is displayed at the bottom of the characteristic's table row";


// Uart
"uart_tab_title" = "UART";
"uart_navigation_title_format" = "UART - %@";


"uart_send_action" = "Send";
"uart_send_toall_action" = "To All";
"uart_send_toall_long" = "All Connected Peripherals";

"uart_sentbytes_format" = "Sent: %ld bytes";
"uart_receivedbytes_format" = "Received: %ld bytes";
"uart_timestamp_direction_rx" = "RX";
"uart_timestamp_direction_tx" = "TX";
"uart_text_dataomitted" = "(Previous data omitted to improve performance…)";

"uart_mqtt_action" = "MQTT";
"uart_mqtt_undefinedserver" = "Mqtt server not defined";
"uart_mqtt_editsettings" = "Edit Mqtt Settings";

"uart_mqtt_status_default" = "MQTT";
"uart_mqtt_status_connecting" = "MQTT: connecting...";
"uart_mqtt_status_connected" = "MQTT: connected";
"uart_mqtt_status_disconnected" = "MQTT: disconnected";
"uart_mqtt_connectionerror_title" = "Connection Error";
"uart_mqtt_editsettings_action" = "Edit Mqtt Settings";

"uart_export_nodata" = "No data to export";
"uart_export_save_message" = "Export Data to File";
"uart_export_save_prompt" = "Export";

"uart_settings_displayMode_title" = "Display Mode";
"uart_settings_displayMode_timestamp" = "Timestamp";
"uart_settings_displayMode_text" = "Text";
"uart_settings_dataMode_title" = "Data Mode";
"uart_settings_dataMode_hex" = "Hex";
"uart_settings_dataMode_ascii" = "Ascii";
"uart_settings_echo_title" = "Show Echo";
"uart_settings_eol_title" = "Send EoL";
"uart_settings_eolCharacters_title" = "EoL Characters";
"uart_eolmode_n" = "\\n";
"uart_eolmode_r" = "\\r";
"uart_eolmode_nr" = "\\n\\r";
"uart_eolmode_rn" = "\\r\\n";

"uart_mqtt_settings_title" = "MQTT Settings";
"uart_mqtt_settings_group_status" = "Status";
"uart_mqtt_settings_group_server" = "Server";
"uart_mqtt_settings_group_publish" = "Publish";
"uart_mqtt_settings_group_subscribe" = "Subscribe";
"uart_mqtt_settings_group_advanced" = "Advanced";
"uart_settings_clear_title" = "Clear";
"uart_settings_export_title" = "Export...";

"uart_help_title" = "UART";
"uart_help_text" = "Instructions:

• Tap the input field at the bottom of the screen.

• Enter the text string you want to send.

• Send a message by pressing the keyboard's Send button.

• Use the Timestamp/Text and ASCII/Hex control above the main console view to control the display format of messages.

• Use the Export button to copy or send the contents of the console.

• Use the Clear button to clear the console's contents.";

"uart_error_peripheralinit" = "Uart protocol can not be initialized";
"uart_error_multipleperiperipheralinit_format" = "Uart protocol can not be initialized for peripheral: %@";

// Mqtt
"mqtt_connection_lost" = "Mqtt server connection failed";
"mqtt_connection_failed" = "Mqtt connection to server lost";

// Plotter
"plotter_tab_title" = "Plotter";
"plotter_navigation_title_format" = "Plotter - %@";
"plotter_autoscroll" = "AutoScroll:";
"plotter_width" = "Width:";
"plotter_nodata" = "No chart data available";

"plotter_help_title" = "Plotter";
"plotter_help_text" = "• The 'Plotter' utility can be used to plot incoming numeric data in a chart, without having to create a custom plotter code or application. It behaves similarly to the Serial Plotter in recent versions of the Arduino IDE.

•  To plot one or more data streams to the plotter, send your numeric data in CSV format with one of the following seperators:
',' - Comma (0x2C)
' ' - Space (0x20)
';' - Semicolon (0x3B)
Horizontal Tab (0x09), '\\t' in code

Each unique set of data samples must be terminated by a LINE FEED character (0x0A), which is usually represented as '\\n' in code.

• Only numeric data should be sent over the BLE UART connection(s).";

// Dfu
"dfu_tab_title" = "Updates";
"dfu_navigation_title_format" = "Updates - %@";

"dfu_currentversion_title" = "Installed Firmware";
"dfu_firmwarereleases_title" = "Firmware Releases";
"dfu_bootloaderreleases_title" = "Bootloader Releases";

"dfu_firmware_format" = "Firmware: %@";
"dfu_betaversion_format" = "Beta Version %@";
"dfu_version_format" = "Version %@";

"dfu_choose_firmware_action" = "Use Custom Firmware";

"dfu_pickfiles_customfirmware_title" = "Select Custom Firmware";
"dfu_pickfiles_custombootloader_title" = "Select Custom Bootloader";
"dfu_pickfiles_hex_title" = "Hex File:";
"dfu_pickfiles_init_title" = "Init File:";
"dfu_pickfiles_hex_action" = "Choose";
"dfu_pickfiles_init_action" = "Choose";
"dfu_pickfiles_file_empty" = "<No file selected>";
"dfu_pickfiles_update_action" = "Start Update";
"dfu_pickfiles_error_hexmissing" = "At least an Hex file should be selected";
"dfu_pickfiles_error_noexplorer_title" = "Unavailable";
"dfu_pickfiles_error_noexplorer_message" = "File browser app not has not been found on your device. You should install an app like Dropbox, GoogleDrive…";


"dfu_install_action_title_format" = "Install firmware version %@?";
"dfu_install_action_message" = "The firmware will be downloaded and updated. Please wait until the process finishes before disconnecting the peripheral";
"dfu_unabletoupdate_bootloader_format" = "This firmware update is not compatible with your bootloader. You need to update your bootloader to version %@ before installing this firmware release %@";

"dfu_disnotavailable" = "Device Information Service not found. Unable to peform an OTA DFU update";
"dfu_dfunotavailable" = "No DFU Service found on device";
"dfu_legacybootloader" = "The legacy bootloader on this device is not compatible with this application";
"dfu_error_invalidfirmware" = "Firmware files not valid";
"dfu_error_bluetootherror" = "Bluetooth not ready";

"dfu_updatecompleted_message" = "Update completed successfully";
"dfu_updatecancelled_message" = "Update cancelled";
"dfu_updateaborted_message" = "Update aborted";
"dfu_download_hex_message" = "Downloading hex file";
"dfu_download_init_message" = "Downloading init file";
"dfu_download_firmware_message" = "Downloading firmware";
"dfu_download_bootloader_message" = "Downloading bootloader";

"dfu_help_title" = "Firmware Updates";
"dfu_help_text" = "Instructions:

• Select one of the updates availables for the peripheral

• Use specific \"hex\" and \"init\" files to update your device. Please take into account that this could brick the peripheral if the firmware is not compatible";

// PinIO
"pinio_tab_title" = "Pin I/O";
"pinio_navigation_title_format" = "Pin I/O - %@";

"pinio_capabilityquery_querying_title" = "Querying pin capabilities...";

"pinio_capabilityquery_expired_title" = "No response to capability query";
"pinio_capabilityquery_expired_message" = "Assuming default pin format
(Arduino Uno)";

"pinio_pins_header" = "Available Pins";
"pinio_pintype_unknown" = "Unknown";
"pinio_pintype_input" = "Input";
"pinio_pintype_output" = "Output";
"pinio_pintype_pwm" = "PWM";
"pinio_pintype_servo" = "Servo";
"pinio_pintype_analog" = "Analog";
"pinio_pintype_low" = "Low";
"pinio_pintype_high" = "High";
"pinio_pintype_input_floating" = "Floating";
"pinio_pintype_inputfloating_long" = "Input Floating";
"pinio_pintype_input_pullup" = "Pull Up";
"pinio_pintype_inputpullup_long" = "Input Pullup";
"pinio_pinname_digital_format" = "Pin %ld";
"pinio_pinname_analog_format" = "Pin %ld, Analog %ld";
"pinio_tag_mode" = "Mode";

"pinio_help_title" = "Pin I/O";
"pinio_help_text" = "Instructions:

• The Pin I/O mode works with an Arduino board running the BLEFirmata sketch.  Detailed instructions can be found here:
https://learn.adafruit.com/bluefruit-le-connect-for-ios/pin-i-slash-o

• Tap a row in the table corresponding to the Arduino pin you want to control.

• Select a pin mode: 
   Input - monitor pin's state
   Output - enable setting of pin state
   Analog - monitor Analog pin input
   PWM - set a pin's pulse width  output

• Set an Output pin's state using the Low/High control.

• Set a PWM pin's output value using the slider control.

• Once finished setting a pin's mode or state, you can close it by tapping the empty space near it's top - or by selecting another row.";

// Controller
"controller_tab_title" = "Controller";
"controller_navigation_title_format" = "Controller - %@";

"controller_uartwarning" = "Please ensure that your Bluefruit LE module is set to DATA/UART mode when using this module";

"controller_sensor_title" = "Stream Sensor Data";
"controller_module_title" = "Module";

"controller_sensor_quaternion" = "Quaternion";
"controller_sensor_accelerometer" = "Accelerometer";
"controller_sensor_gyro" = "Gyro";
"controller_sensor_magnetometer" = "Magnetometer";
"controller_sensor_location" = "Location";

"controller_component_lat" = "lat";
"controller_component_long" = "long";
"controller_component_alt" = "alt";
"controller_component_x" = "x";
"controller_component_y" = "y";
"controller_component_z" = "z";
"controller_component_w" = "w";

"controller_sensor_location_disabled" = "Location Services Disabled";
"controller_sensor_location_restricted" = "This module is not authorized to use location services";
"controller_sensor_location_denied" = "Location Services are disabled. Go to settings and enable location services for this app to use this feature.";
"controller_sensor_locationpermission_text" = "Please grant fine location access to show the current location";
"controller_location_unknown" = "Waiting for location data…";
"controller_magnetometermissing" = "Your device doesn't have a magnetic sensor";

"controller_module_pad" = "Control Pad";
"controller_module_colorpicker" = "Color Picker";

"controller_help_title" = "Controller";
"controller_help_text" = "The Controller module streams sensor data from your iOS device to Bluefruit LE over UART at a frequency of 10Hz.  Activation of a switch will begin sending relevant data.  Each packet sent begins with single byte char “!” (0x21) followed by a single byte char initial, and sensor data encoded as float values of 4 byte length

• Quaternion sends iOS Device Motion data to describe device attitude.  This data is derived from Accelerometer, Gyro, and Magnetometer readings.
Format: [ ‘!’ ] [ ‘Q’ ] [ float x ] [ float y ] [ float z ] [ float w ]

• Accelerometer sends raw accelerometer data
Format: [ ‘!’ ] [ ‘A’ ] [ float x ] [ float y ] [ float z ]

• Gyro sends raw gyroscope data as:
Format: [ ‘!’ ] [ ‘G’ ] [ float x ] [ float y ] [ float z ]

• Magnetometer sends raw magnetometer data which is uncalibrated and does not account for interference from source device.
Format: [ ‘!’ ] [ ‘M’ ] [ float x ] [ float y ] [ float z ]

• Location sends GPS data and requires user permission before initial use.
Format: [ ‘!’ ] [ ‘L’ ] [ float latitude ] [ float longitude ] [ float altitude ]";

// Control Pad

"controlpad_title" = "Control Pad";

"controlpad_help_title" = "Control Pad";
"controlpad_help_text" = "The Control Pad function provides a familiar momentary button interface for common control scenarios.  Data is sent on the press and release of each button.  Each packet consists of 4 bytes, each representing a char value.  The first two chars identify the packet as a button message, the third specifies a button, and the fourth signifies either a press or release.  Example:

Button 4 pressed:  [ ‘!’ ] [ ‘B’ ] [ ‘4’ ] [ ‘1’ ]
Button 4 released: [ ‘!’ ] [ ‘B’ ] [ ‘4’ ] [ ‘0’ ]

Note: Any activated sensor data streams will continue while using the Control Pad.";

// Color Picker

"colorpicker_title" = "Color Picker";

"colorpicker_brightness" = "Brightness:";
"colorpicker_saturation" = "Saturation:";
"colorpicker_wcomponent" = "W component:";
"colorpicker_rgb_format" = "RGB: %ld-%ld-%ld";
"colorpicker_rgbw_format" = "RGBW: %ld-%ld-%ld-%ld";
"colorpicker_hex_format" = "Hex: %@";
"colorpicker_select_action" = "Select";

"colorpicker_boardselector_action" = "Board Selector";
"colorpicker_boardtype_action" = "Board Type";


"colorpicker_help_title" = "Color Picker";
"colorpicker_help_text" = "The Color Picker sends a color's RGB values to Bluefruit LE.  This can be used to control the state of RGB LEDs such as Neopixels.

• Touch the color wheel to choose desired color

• Press Send to send the chosen color's red, green, and blue values to Bluefruit via UART in the following format:
[ ‘!’ ] [ ‘C’ ] [ byte r ] [ byte g ] [ byte b ]";


// NeoPixels
"neopixels_tab_title" = "Neopixels";
"neopixels_navigation_title_format" = "Neopixels - %@";

"neopixels_status_title" = "Status:";
"neopixels_connect_action" = "Connect";

"neopixels_waitingforuart" = "Waiting for Uart...";
"neopixels_status_readytoconnect" = "Ready to Connect";
"neopixels_status_waitingsetup" = "Waiting for Setup";
"neopixels_status_readyforsetup" = "Ready for Setup";
"neopixels_status_connected" = "Connected";
"neopixels_status_checkingsketch" = "Checking Sketch...";
"neopixels_status_notdetected" = "Not detected";

"neopixels_picker_title" = "Picker:";
"neopixels_brightness_title" = "Brightness:";
"neopixels_colorpicker_setcolor" = "Set";

"neopixel_help_title" = "NeoPixels";
"neopixel_help_text" = "To use the NeoPixel application:

• Open Bluefruit LE Connect Neopixel sketch on the Arduino IDE and run it
• Connect to your Bluefruit module and switch to the NeoPixel utility
• Click the 'gear' icon and set your board size (8x4, 1x8, etc.)
• Click the Connect button in the Bluefruit LE Connect app
• Select a color and tap individual pixels to set them
• Adjust overall brightness as desired using the Brightness slider";
"neopixel_sketch_tooltip" = "Neopixel support requires a custom sketch to be running on your Arduino.";

// Neopixels Board Selector
"neopixelboardselector_standardboardsizes_title" = "Standard board sizes";
"neopixelboardselector_customboardsize_title" = "Custom board size";
"neopixelboardselector_customboardsize_linestrip" = "Line Strip";
"neopixelboardselector_linestriplength_title" = "Select line strip length";
"neopixelboardselector_linestriplength_hint" = "Enter length";
"neopixelboardselector_linestriplength_action" = "Select";

// Neopixels Component Selector
"neopixelcomponentselector_speed_title" = "Speed";
"neopixelcomponentselector_pixelorder_title" = "Pixel Order";
"neopixelcomponentselector_speed_400khz" = "400 Khz Mode";

// Calibration
"calibration_tab_title" = "AHRS/Calibration";
"calibration_navigation_title_format" = "AHRS/Calibration - %@";

// Thermal Camera
"thermalcamera_tab_title" = "Thermal Camera";
"thermalcamera_navigation_title_format" = "Thermal Camera - %@";

"thermalcamera_waitingforuart" = "Waiting for Uart...";
"thermalcamera_colormode_title" = "Color Mode:";
"thermalcamera_colormode_color" = "Color";
"thermalcamera_colormode_monochrome" = "Monochrome";
"thermalcamera_magnification_title" = "Magnification:";
"thermalcamera_magnification_pixelated" = "Pixelated";
"thermalcamera_magnification_filtered" = "Filtered";

"thermalcamera_temprange_title" = "Temperature Range:";


// Common
"dialog_ok" = "OK";
"dialog_cancel" = "Cancel";
"dialog_error" = "Error";
"dialog_notice" = "Notice";
"dialog_dontshowagain" = "Don't show again";

"common_help_action" = "Help";


// About
"about_title" = "About";
"about_app_name" = "Bluefruit LE Connect";
"about_android_text" = "A detailed guide to using this app can be found here:
https://learn.adafruit.com/bluefruit-le-connect-for-ios

Configure your Bluefruit LE hardware using instructions found here:
http://www.adafruit.com/bluefruitle

Drag the table down and release to clear the list of found peripherals and begin scanning

Tap a row in the table to view a peripheral's advertisement data.

Each peripheral's Received Signal Strength (RSSI) is displayed to the left of its name.

Tap a row's connect button to connect the corresponding device in one of the available modes:

• Info - displays peripheral services & characteristics

• UART - basic terminal, send & receive data 

• Pin I/O - uses Bluefruit's UART to control Arduino running BLEFirmata sketch:
https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout/software-bluefruit-firmata

• Controller - streams sensor data from your iOS device to Bluefruit LE over UART

• Plotter - can be used to plot incoming numeric data in a chart

• Updates - update device firmware



Acknowledgements

Portions of this Software may utilize the following copyrighted material, the use of which is hereby acknowledged. 

Android-DFU-Library
Copyright (c) 2015, Nordic Semiconductor
https://github.com/NordicSemiconductor/Android-DFU-Library

Android-Scanner-Compat-Library
Copyright (c) 2015, Nordic Semiconductor
https://github.com/NordicSemiconductor/Android-Scanner-Compat-Library

Eclipse Paho
https://eclipse.org/paho/clients/java/

MPAndroidChart
https://github.com/PhilJay/MPAndroidChart";
"about_ios_text" = "A detailed guide to using this app can be found here:
https://learn.adafruit.com/bluefruit-le-connect-for-ios

Configure your Bluefruit LE hardware using instructions found here:
http://www.adafruit.com/bluefruitle

Drag the table down and release to clear the list of found peripherals and begin scanning

Tap a row in the table to view a peripheral's advertisement data.

Each peripheral's Received Signal Strength (RSSI) is displayed to the left of its name.

Tap a row's connect button to connect the corresponding device in one of the available modes:

• Info - displays peripheral services & characteristics

• UART - basic terminal, send & receive data 

• Pin I/O - uses Bluefruit's UART to control Arduino running BLEFirmata sketch:
https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout/software-bluefruit-firmata

• Controller - streams sensor data from your iOS device to Bluefruit LE over UART

• Plotter - can be used to plot incoming numeric data in a chart

• Updates - update device firmware



Acknowledgements

Portions of this Software may utilize the following copyrighted material, the use of which is hereby acknowledged. 

IOS-Pods-DFU-Library
Copyright (c) 2016, Nordic Semiconductor
https://github.com/NordicSemiconductor/IOS-Pods-DFU-Library

CocoaMQTT
Copyright (c) 2014 emqtt
https://github.com/emqtt/CocoaMQTT

SwiftyXML
Copyright (c) 2016 ChenYunGui (陈云贵)
https://github.com/chenyunguiMilook/SwiftyXML

Charts
Copyright 2016 Daniel Cohen Gindi & Philipp Jahoda
https://github.com/danielgindi/Charts

iOS-Color-Wheel
https://github.com/justinmeiners/ios-color-wheel

UIColor-Hex
Copyright (C) 2011-2014, Tom Adriaenssen
https://github.com/Inferis/UIColor-Hex

VectorMath
Copyright (c) 2014 Nick Lockwood. All rights reserved.
https://github.com/nicklockwood/VectorMath";